\chapter[Conclusions and Possibilities of Future Work]{Conclusions}\label{chapter:conclusions}

The development of the SPM tool shows that there are situations where the placement of the memory pages plays a crucial role in the performance of the algorithm running on a NUMA system. SPM leverages on the presence of a Performance Measurement Unit (PMU) that gives memory latency information in order to detect the expensive accesses that are candidate remote accesses and could be relocated in order to improve the performance of the observed process.

The tool must form itself a picture of the behavior of the memory space of the observed algorithm. Since the PMU uses the sampling principle, not every instruction executed is captured and only a part of the memory behavior is captured by the sampling system. The greatest the number of samples captured the best the remedial action will be in order to improve the performance of the observed algorithm. In order to maximize the number of samples the period of the performance measurement unit must be a low figure and also a reasonable observation time must be left for the tools to accumulate a representative amount of samples, but if the observation portion of the observed process is too long the remaining time running under improved conditions will not be enough to make up for the part of the program running in optimal conditions.

The obtained improvements range between the best possible case, where all the pages are local to the requesting node and the worst case, where all the pages are located in a node different than the requesting node. The result on random access patterns was found better than on the sequential patterns. The performance measurement itself can also work as a witness of the tools action by examining the improvements achieved by the changes in the number of executed instructions, remote and local memory accesses.
The concluded implementation leads to the integration possibility with a thread pinning tool, such as Autopin where both tools can reach together to reach an efficient thread and program memory allocation where SPM helps fix the inefficient memory allocations that might be caused by a thread re-pinning. The tool also has a reasonable demand of resources by taking a dedicated core for its functioning.

The next advisable direction to move toward is the implementation of more elaborate allocation policies, the further optimization of the page migration process and the test of algorithms that present more contention.

\section{Questions Left and Possibilities of Future Work}\label{section:resfutwork}

A good next step would go in the direction of characterizing SPMs performance and search for any room for possible improvement. The page migration phase takes a long amount of time and the time require to migrate the chunks of two hundred pages was longer than the one obtained in the characterization done in section \ref{subsection:pmu-movpatime}: while the characterization showed an average time of maximum 0.35 seconds in the contention scenario in the full core SPM runs these times were between 1.5 and 4 seconds. It is also worth looking further why the performance reached even after moving all the pages is never the same as the local case.
 
The contention analysis also shows that the algorithms tested showed very good localization properties which means there was low contention for pages, it good be appropriate to test the tool with algorithms of grater contention in order to see how it reacts to this situation.
Unfortunately due to time constraints out of the strategies pointed in section \ref{section:placement strats} only co-location could be tested. The test with more strategies would lead to a more comprehensive tool.
