\chapter[Conclusions and Possibilities of Future Work]{Conclusions}\label{chapter:conclusions}

The development of the SPM tool shows that there are situations where the placement of the memory pages plays a crucial role in the performance of the algorithm running on a NUMA system. SPM leverages on the presence of a Performance Measurement Unit (PMU) that gives memory latency information in order to detect the expensive accesses that are candidate remote accesses and could be relocated in order to improve the performance of the observed process.
The tool must form itself a picture of the behavior of the memory space of the observed algorithm. Since the PMU uses the sampling principle, not every instruction executed is captured and only a part of the memory behavior is captured by the sampling system. The greatest the number of samples captured the best the remedial action will be in order to improve the performance of the observed algorithm. In order to maximize the number of samples the period of the performance measurement unit must be a low figure and also a reasonable observation time must be left for the tools to accumulate a representative amount of samples, but if the observation portion of the observed process is too long the remaining time running under improved conditions will not be enough to make up for the part of the program running in optimal conditions.

The obtained improvements range between the best possible case, where all the pages are local to the requesting node and the worst case, where all the pages are located in a node different than the requesting node. The result on random access patterns was found better than on the sequential patterns. The performance measurement itself can also work as a witness of the tools action by examining the improvements achieved by the changes in the number of executed instructions, remote and local memory accesses.
The concluded implementation leads to the integration possibility with a thread pinning tool, such as Autopin where both tools can reach together to reach an efficient thread and program memory allocation where SPM helps fix the inefficient memory allocations that might be caused by a thread re-pinning. The tool also has a reasonable demand of resources by taking a dedicated core for its functioning.
The next advisable direction to move toward is the implementation of more elaborate allocation policies, the further optimization of the page migration process and the test of algorithms that present more contention.
